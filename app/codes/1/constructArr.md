### 构建乘积数组

> 题目:给定一个数组 `A[0,1,…,n-1]`，请构建一个数组 `B[0,1,…,n-1]`，其中  `B[i]` 的值是数组 A 中除了下标 i 以外的元素的积, 即  `B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]`。不能使用除法。

示例 1：

```js
// 输入: [1,2,3,4,5]
// 输出: [120,60,40,30,24]
```

提示:

- 所有元素乘积之和不会溢出 32 位整数
- a.length <= 100000

### 思路分析

本题我们可以通过表格分区来解决。如下图所示:

![](../../images/constructArr-1.png)

如图所示，我们可以根据对角线全是 1 的定律，将表格分为上三角和下三角，因此，我们只需要分别迭代结算上三角和下三角的乘积，最后再将上三角和下三角的进行合并即可。

算法流程如下:

1. 初始化数组 B，并初始化 B[0] = 1,以及初始化辅助变量 temp 为 1（为 1 方便做乘法）。
2. 计算 B[i]的下三角的乘积，直接乘入到数组 B[i]中。
3. 计算 B[i]的上三角的乘积，并乘入辅助变量 temp，然后乘入到数组 B[i]中。
4. 返回数组 B。

```js
/**
 * @param {number[]} a
 * @return {number[]}
 */
var constructArr = function (a) {
  let b = [];
  // 如果数组a的长度为空，直接返回
  if (!a.length) {
    return b;
  }
  // 初始化辅助变量和B数组
  let temp = 1;
  b[0] = 1;
  // 由于初始化为1，因此需要从1开始循环,计算下三角
  for (let i = 1; i < a.length; i++) {
    // 计算B[i]的乘积
    b[i] = a[i - 1] * b[i - 1];
  }
  // 计算上三角
  // 由于上三角是从倒数第二项开始的，因此需要减2
  for (let j = a.length - 2; j >= 0; j--) {
    // 将乘积乘入辅助变量，然后再乘入b数组
    temp *= a[j + 1];
    b[j] *= temp;
  }
  // 返回数组b
  return b;
};
```

- 时间复杂度 O(n)： 其中 n 为数组长度，两轮遍历数组 a ，使用 O(n) 时间。
- 空间复杂度 O(1)： 变量 temp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。

[更多思路](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/)。
