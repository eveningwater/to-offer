### 不用加减乘除做加法

> 题目:写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“\*”、“/” 四则运算符号。

示例 1：

```js
// 输入: a = 1, b = 1
// 输出: 2
```

提示:

- a, b 均可能是负数或 0
- 结果不会溢出 32 位整数

### 思路分析

本题如果不能用常规的做法来解答，那么我们就只能考虑底层的位运算呢。因此，我们首先需要将两个整数转换成二进制，设两个数的二进制分别为 a 和 b。求和 s = a + b 会分为以下四种情况。（设 a(i)和 b(i)分别为两个数的二进制的第 i 位）

| a(i) | b(i) | 无进位和 n(i) | 进位 c (i + 1) |
| ---- | ---- | ------------- | -------------- |
| 0    | 0    | 0             | 0              |
| 0    | 1    | 1             | 0              |
| 1    | 0    | 1             | 0              |
| 1    | 1    | 0             | 1              |

根据上表，我们可以看到，二进制只会是 0 和 1，如果是 2 的话就会进位。再对比位操作符的含义，我们可以发现，无进位和就和按位异或操作符“^”规律相同。进位则与按位与“&”运算规律相同，并且我们也知道进位了之后，是需要左移一位的。因此无进位和 n 与进位 c，我们可以表示成如下:

1. n = a ^ b 无进位和：异或运算
2. c = a & b << 1 进位：与运算 + 左移一位

(和 s) = (无进位和 n) + (进位 c)。即可将 s = a + b 转换成 s = n + c。因此我们只需要循环求 n 和 c，直到 c = 0,也就是进位为 0，此时 s = n，返回 n 即可。如下图所示:

![](../../images/add-1.png)

这里可能会有疑问，假如 a 和 b 中有负数，此时不就成了减法吗？该如何计算呢。其实在计算机系统中，负数一律采用补码来表示和存储。而补码的优势就是加法和减法统一处理，因为 CPU 只有加法器。因此，以上方法同样适合负数。

> 如果对位操作符的定义不清楚，可以查看[此文章](https://segmentfault.com/a/1190000018241410)。

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var add = function (a, b) {
  // 当b为0，代表进位为0，则跳出循环
  while (b !== 0) {
    let c = (a & b) << 1;
    a ^= b;
    // b将变换进位
    b = c;
  }
  return a;
};
```

- 时间复杂度 O(1)： 最差情况下（例如 a = 0x7fffffff , b = 1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。
- 空间复杂度 O(1)： 使用常数大小的额外空间。

[更多思路](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mian-shi-ti-65-bu-yong-jia-jian-cheng-chu-zuo-ji-7/)。
