###  路径的数目
 
> 题目:一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

示例1：

![](../../images/2/uniquePaths-1.png)

```js
// 输入：m = 3, n = 7
// 输出：28
```


示例2：

```js
// 输入：m = 3, n = 2
// 输出：3
// 解释：
// 从左上角开始，总共有 3 条路径可以到达右下角。
// 1. 向右 -> 向下 -> 向下
// 2. 向下 -> 向下 -> 向右
// 3. 向下 -> 向右 -> 向下
```

示例3：

```js
// 输入：m = 7, n = 3
// 输出：28
```

示例4：

```js
// 输入：m = 3, n = 3
// 输出：6
```

提示:

*  1 <= m, n <= 100
*  题目数据保证答案小于等于 2 * 10 ^ 9


> 注意：本题与[主站 62 题](https://leetcode-cn.com/problems/unique-paths/)相同。

### 思路分析

本题我们可以考虑采用动态规划的算法来解答，我们用f(i,j)表示从左上角走到(i,j)的路径数量，其中i和j的范围分别是[0,m)和[0,n)。由于我们每次只能向下或者向右走一步，因此想要走到(i,j),如果是向下走一步，那么就是从(i-1,j)走过来，同理如果是向右走一步，那么就会从(i,j - 1)走过来。因此我们就可以得出动态规划的转移方程:

f(i,j) = f(i−1,j) + f(i,j−1)

需要注意的就是，当i = 0,那么f(i - 1,j)并不是一个满足要求的状态，因此我们需要忽略这一项，同理当j = 0,f(i,j - 1)也不是一个满足要求的状态，我们也需要忽略这一项。初始条件f(0,0) = 1，即从左上角走到左上角有一种方法。最终的答案即为f(m - 1,n - 1)。

为了方便代码的编写，我们将所有的f(0,j)以及f(i,0)都设置为边界条件，它们的值都是1。

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
    for(let i = 0;i < m;i++){
        dp[i][0] = 1;
    }
    for(let j = 0;j < n;j++){
        dp[0][j] = 1;
    }
    for(let i = 1;i < m;i++){
        for(let j = 1;j < m;j++){
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
};
```

以上算法的时间复杂度和空间复杂度分析如下:

* 时间复杂度：O(m * n)。
* 空间复杂度：O(m * n),即为存储所有状态需要的空间。注意到 f(i, j) 仅与第 i 行和第 i-1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。此外，由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换 m 和 n 使得 m ≤ n，这样空间复杂度降低至O(min(m,n))。


[更多思路](https://leetcode-cn.com/problems/2AoeFn/solution/lu-jing-de-shu-mu-by-leetcode-solution-ozcc/)。
