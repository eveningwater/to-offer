###  最大的异或

> 题目:给定一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。

示例1：

```js
// 输入：nums = [3,10,5,25,2,8]
// 输出：28
// 解释：最大运算结果是 5 XOR 25 = 28.
```

示例2：

```js
// 输入：nums = [0]
// 输出：0
```

示例3：

```js
// 输入：nums = [2,4]
// 输出：6
```

示例4：

```js
// 输入：nums = [8,10,2]
// 输出：10
```

示例5：

```js
// 输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
// 输出：127
```

提示:

* 1 <= nums.length <= 2 * 10 ^ 4
* 0 <= nums[i] <= 2 ^ 31 - 1

> 进阶：你可以在 O(n) 的时间解决这个问题吗？


> 注意：本题与[主站 421 题](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)相同。

### 思路分析

要解答本题，首先需要理解按位异或(^)的性质。假设我们已经在数组中找到了两个数值a和b的异或值为x，对于在数组当中，我们则表示为a[i]与a[j](i !== j)，因此可得到一个表达式为:

x = a[i] ^ a[j]。

根据按位异或的性质,a[i] ^ a[j] = x可以得出a[j] = x ^ a[i]。虽然在本题中我们可以使用暴力循环，分别对每一个数进行按位异或运算，然后找到最大值，但是这样做的时间复杂度为O(n ^ 2),会超出时间限制，因此本题我们不能使用暴力循环来解答。根据前面所说的a[j] = x ^ a[i]，因此我们可以设计一种计算x的最高位到最低位的二进制位的方法，以此来得到x的值。该方法的精髓在于:

* 由于数组中的元素都在 [0,2 ^ 31] 的范围内，那么我们可以将每一个数表示为一个长度为 31 位的二进制数（如果不满 31 位，在最高位之前补上若干个前导 0 即可）；
* 这 31 个二进制位从低位到高位依次编号为 0, 1,⋯,30。我们从最高位第 30 个二进制位开始，依次确定 x 的每一位是 0 还是 1；
* 由于我们需要找出最大的 x，因此在枚举每一位时，我们先判断 x 的这一位是否能取到 1。如果能，我们取这一位为 1，否则我们取这一位为 0。

那么我们应该如何来判断x的这一位能否取到1？，这是一个比较复杂的步骤。假设我们确定了x的最高的若干个二进制位，当前正在确定第k个二进制位，根据前面所述，我们要让第k个二进制位取值为1，我们用pre<sup>k</sup>(x)表示从最高位第30个二进制位开始，到第k个二进制位结束的二进制数，罢了a[j] = x ^ a[i]也就意味着:

pre<sup>k</sup>(a[j]) = pre<sup>k</sup>(x) ^ pre<sup>k</sup>(a[i])。

由于pre<sup>k</sup>(x)对于我们来说是已知的，因此我们将所有的pre<sup>k</sup>(a[j])放置到哈希表中，随后遍历数组的每一个元素，计算pre<sup>k</sup>(x) ^ pre<sup>k</sup>(a[i])。如果其出现在哈希表中，则代表第k个二进制位能够取到1，否则第k个二进制位只能为0。根据这种思路，我们可以写出如下的代码:

> 注意:计算pre<sup>k</sup>(a[j])可以使用右移操作符`>>`。（右移的意思就是将二进制数的每一位向右移动n位，左边移动的全部变成0，参考这里去理解[浅谈JavaScript位操作符](https://segmentfault.com/a/1190000018241410#item-5)）

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaximumXOR = function(nums) {
    //最高位为30
    const HIGH_BIT = 30;
    //定义x
    let x = 0;
    //注意二进制位有31位，所以需要大于等于0
    for(let k = HIGH_BIT;k >= 0;k--){
        //初始化哈希表，也可以用Set
        const map = new Map();
        //将所有的pre ^ k(a[j])都放置到哈希表中
        for(const num of nums){
            //如果要存储pre ^ k(a[j]),则只需要右移k位即可
            map.set(num >> k,num);
        }
        let xNext = x * 2 + 1,//目前x包含从最高位到第k + 1个二进制位为止的部分，我们将第k个二进制位设置为1，即x * 2 + 1
            found = false; //用于判断哈希表中是否存在pre ^ k(a[j])
        //遍历数组
        for(const num of nums){
            //判断哈希表中是否存在pre ^ k(a[j]),找到则停止遍历
            if(map.has(xNext ^ (num >> k))){
                found = true;
                break;
            }
        }
        if(found){
            x = xNext;
        }else{
            //如果没有找到满足等式的a[i]与a[j],则需要将第k个二进制位设置为0,即x = x * 2
            x = xNext - 1;
        }
    }
    return x;
};
```

以上算法的时间复杂度和空间复杂度分析如下:

* 时间复杂度：O(n * logC)，其中 n 是数组 nums 的长度，C 是数组中的元素范围，在本题中 C < 2 ^ 31枚举答案 x 的每一个二进制位的时间复杂度为 O(logC)，在每一次枚举的过程中，我们需要 O(n) 的时间进行判断，因此总时间复杂度为 O(n * logC)。
* 空间复杂度：O(n)，即为哈希表需要使用的空间。

[更多思路](https://leetcode-cn.com/problems/ms70jA/solution/zui-da-de-yi-huo-by-leetcode-solution-hr7m/)。
