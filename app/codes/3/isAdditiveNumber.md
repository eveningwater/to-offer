### 累加数

> 题目: 累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的累加序列必须至少包含3个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。


示例 1：

```js
// 输入："112358"
// 输出：true 
// 解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```


示例 2：

```js
// 输入："199100199"
// 输出：true 
// 解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

提示:

* 1 <= num.length <= 35
* num 仅由数字（0 - 9）组成

> 进阶：你计划如何处理由过大的整数输入导致的溢出?

### 思路分析

本题咋一看，似乎根本没有什么好方法来解题，因此我们可以尝试采用暴力解法，根据题意，对于一个有累加序列的数字字符串，首先必须要满足字符串的长度大于3，因为只有大于3，才会有累加序列。而什么是累加序列？也就是说有三个数，前面两个数相加起来的和必定是第三个数。

知道了这点之后，我们就能够确定枚举的方式了，但是这里有一个难点，那就是第一个数以及第二个数还有第三个数的位数是不确定的，因此我们需要截取字符串来分别作为第一个数，第二个数和第三个数。

这里我们可以采用深度优先搜索算法，去枚举出所有的可能性，怎么做呢？首先是从以i作为循环变量，在0 ~ n - 2 开始截取出第一个数，从i + 1开始，以j作为循环变量，在0 ~ n - 1中截取出第二个数，然后以j + 1开始截取第三个数，这里当第三个数的索引值即j + 1开始，如果等于了字符串的长度，代表已经枚举完成，就直接返回true，为什么要这么做？因为我们已经在枚举时去做判断了，如果枚举完成那就代表一定出现了累加序列。

还有一点需要注意，那就是第一个数和第二个数如果长度大于1，并且首位是0，那就需要跳过。

综上分析，可以写出如下代码:

```js
/**
 * @param {string} num
 * @return {boolean}
 */
var isAdditiveNumber = function(num) {
    const n = num.length;
    if(n < 3){
        return false;
    }
    const dfs = (start,first,second) => {
        if(start === n){
            return true;
        }
        for(let i = start;i < n;i++){
            const sum = num.slice(start, i + 1);
            if((sum === first + second + '') && dfs(i + 1,second,sum - 0)){
                return true;
            }
        }
        return false;
    }
    for(let i = 0;i < n - 2;i++){
        for(let j = i + 1;j < n - 1;j++){
            const first = num.slice(0, i + 1),
                  second = num.slice(i + 1,j + 1);

            if(first.length > 1 && first[0] === '0' || second.length > 1 && second[0] === '0'){
                continue
            }
            if(dfs(j + 1,first - 0,second - 0)){
                return true;
            }
        }
    }
    return false;
};
```

以上算法的时间复杂度和空间复杂度分析如下:

* 时间复杂度 O(n ^ 3)： 2个for循环加上一个递归，所以需要O(n ^ 3)。
* 空间复杂度 O(n)：一个递归需要O(n)的空间。

[更多思路](https://leetcode.cn/problems/additive-number/solution/lei-jia-shu-by-leetcode-solution-cadc/)。
